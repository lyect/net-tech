// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: snakes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_snakes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_snakes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_snakes_2eproto;
namespace snakes {
class GameAnnouncement;
class GameAnnouncementDefaultTypeInternal;
extern GameAnnouncementDefaultTypeInternal _GameAnnouncement_default_instance_;
class GameConfig;
class GameConfigDefaultTypeInternal;
extern GameConfigDefaultTypeInternal _GameConfig_default_instance_;
class GameMessage;
class GameMessageDefaultTypeInternal;
extern GameMessageDefaultTypeInternal _GameMessage_default_instance_;
class GameMessage_AckMsg;
class GameMessage_AckMsgDefaultTypeInternal;
extern GameMessage_AckMsgDefaultTypeInternal _GameMessage_AckMsg_default_instance_;
class GameMessage_AnnouncementMsg;
class GameMessage_AnnouncementMsgDefaultTypeInternal;
extern GameMessage_AnnouncementMsgDefaultTypeInternal _GameMessage_AnnouncementMsg_default_instance_;
class GameMessage_DiscoverMsg;
class GameMessage_DiscoverMsgDefaultTypeInternal;
extern GameMessage_DiscoverMsgDefaultTypeInternal _GameMessage_DiscoverMsg_default_instance_;
class GameMessage_ErrorMsg;
class GameMessage_ErrorMsgDefaultTypeInternal;
extern GameMessage_ErrorMsgDefaultTypeInternal _GameMessage_ErrorMsg_default_instance_;
class GameMessage_JoinMsg;
class GameMessage_JoinMsgDefaultTypeInternal;
extern GameMessage_JoinMsgDefaultTypeInternal _GameMessage_JoinMsg_default_instance_;
class GameMessage_PingMsg;
class GameMessage_PingMsgDefaultTypeInternal;
extern GameMessage_PingMsgDefaultTypeInternal _GameMessage_PingMsg_default_instance_;
class GameMessage_RoleChangeMsg;
class GameMessage_RoleChangeMsgDefaultTypeInternal;
extern GameMessage_RoleChangeMsgDefaultTypeInternal _GameMessage_RoleChangeMsg_default_instance_;
class GameMessage_StateMsg;
class GameMessage_StateMsgDefaultTypeInternal;
extern GameMessage_StateMsgDefaultTypeInternal _GameMessage_StateMsg_default_instance_;
class GameMessage_SteerMsg;
class GameMessage_SteerMsgDefaultTypeInternal;
extern GameMessage_SteerMsgDefaultTypeInternal _GameMessage_SteerMsg_default_instance_;
class GamePlayer;
class GamePlayerDefaultTypeInternal;
extern GamePlayerDefaultTypeInternal _GamePlayer_default_instance_;
class GamePlayers;
class GamePlayersDefaultTypeInternal;
extern GamePlayersDefaultTypeInternal _GamePlayers_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class GameState_Coord;
class GameState_CoordDefaultTypeInternal;
extern GameState_CoordDefaultTypeInternal _GameState_Coord_default_instance_;
class GameState_Snake;
class GameState_SnakeDefaultTypeInternal;
extern GameState_SnakeDefaultTypeInternal _GameState_Snake_default_instance_;
}  // namespace snakes
PROTOBUF_NAMESPACE_OPEN
template<> ::snakes::GameAnnouncement* Arena::CreateMaybeMessage<::snakes::GameAnnouncement>(Arena*);
template<> ::snakes::GameConfig* Arena::CreateMaybeMessage<::snakes::GameConfig>(Arena*);
template<> ::snakes::GameMessage* Arena::CreateMaybeMessage<::snakes::GameMessage>(Arena*);
template<> ::snakes::GameMessage_AckMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_AckMsg>(Arena*);
template<> ::snakes::GameMessage_AnnouncementMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_AnnouncementMsg>(Arena*);
template<> ::snakes::GameMessage_DiscoverMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_DiscoverMsg>(Arena*);
template<> ::snakes::GameMessage_ErrorMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_ErrorMsg>(Arena*);
template<> ::snakes::GameMessage_JoinMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_JoinMsg>(Arena*);
template<> ::snakes::GameMessage_PingMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_PingMsg>(Arena*);
template<> ::snakes::GameMessage_RoleChangeMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_RoleChangeMsg>(Arena*);
template<> ::snakes::GameMessage_StateMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_StateMsg>(Arena*);
template<> ::snakes::GameMessage_SteerMsg* Arena::CreateMaybeMessage<::snakes::GameMessage_SteerMsg>(Arena*);
template<> ::snakes::GamePlayer* Arena::CreateMaybeMessage<::snakes::GamePlayer>(Arena*);
template<> ::snakes::GamePlayers* Arena::CreateMaybeMessage<::snakes::GamePlayers>(Arena*);
template<> ::snakes::GameState* Arena::CreateMaybeMessage<::snakes::GameState>(Arena*);
template<> ::snakes::GameState_Coord* Arena::CreateMaybeMessage<::snakes::GameState_Coord>(Arena*);
template<> ::snakes::GameState_Snake* Arena::CreateMaybeMessage<::snakes::GameState_Snake>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace snakes {

enum GameState_Snake_SnakeState : int {
  GameState_Snake_SnakeState_ALIVE = 0,
  GameState_Snake_SnakeState_ZOMBIE = 1
};
bool GameState_Snake_SnakeState_IsValid(int value);
constexpr GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MIN = GameState_Snake_SnakeState_ALIVE;
constexpr GameState_Snake_SnakeState GameState_Snake_SnakeState_SnakeState_MAX = GameState_Snake_SnakeState_ZOMBIE;
constexpr int GameState_Snake_SnakeState_SnakeState_ARRAYSIZE = GameState_Snake_SnakeState_SnakeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_Snake_SnakeState_descriptor();
template<typename T>
inline const std::string& GameState_Snake_SnakeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameState_Snake_SnakeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameState_Snake_SnakeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameState_Snake_SnakeState_descriptor(), enum_t_value);
}
inline bool GameState_Snake_SnakeState_Parse(
    const std::string& name, GameState_Snake_SnakeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameState_Snake_SnakeState>(
    GameState_Snake_SnakeState_descriptor(), name, value);
}
enum NodeRole : int {
  NORMAL = 0,
  MASTER = 1,
  DEPUTY = 2,
  VIEWER = 3
};
bool NodeRole_IsValid(int value);
constexpr NodeRole NodeRole_MIN = NORMAL;
constexpr NodeRole NodeRole_MAX = VIEWER;
constexpr int NodeRole_ARRAYSIZE = NodeRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeRole_descriptor();
template<typename T>
inline const std::string& NodeRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeRole_descriptor(), enum_t_value);
}
inline bool NodeRole_Parse(
    const std::string& name, NodeRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeRole>(
    NodeRole_descriptor(), name, value);
}
enum PlayerType : int {
  HUMAN = 0,
  ROBOT = 1
};
bool PlayerType_IsValid(int value);
constexpr PlayerType PlayerType_MIN = HUMAN;
constexpr PlayerType PlayerType_MAX = ROBOT;
constexpr int PlayerType_ARRAYSIZE = PlayerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerType_descriptor();
template<typename T>
inline const std::string& PlayerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerType_descriptor(), enum_t_value);
}
inline bool PlayerType_Parse(
    const std::string& name, PlayerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerType>(
    PlayerType_descriptor(), name, value);
}
enum Direction : int {
  UP = 1,
  DOWN = 2,
  LEFT = 3,
  RIGHT = 4
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = UP;
constexpr Direction Direction_MAX = RIGHT;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Direction_descriptor();
template<typename T>
inline const std::string& Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Direction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Direction_descriptor(), enum_t_value);
}
inline bool Direction_Parse(
    const std::string& name, Direction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Direction>(
    Direction_descriptor(), name, value);
}
// ===================================================================

class GamePlayer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayer) */ {
 public:
  inline GamePlayer() : GamePlayer(nullptr) {};
  virtual ~GamePlayer();

  GamePlayer(const GamePlayer& from);
  GamePlayer(GamePlayer&& from) noexcept
    : GamePlayer() {
    *this = ::std::move(from);
  }

  inline GamePlayer& operator=(const GamePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayer& operator=(GamePlayer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GamePlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GamePlayer* internal_default_instance() {
    return reinterpret_cast<const GamePlayer*>(
               &_GamePlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GamePlayer& a, GamePlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GamePlayer* New() const final {
    return CreateMaybeMessage<GamePlayer>(nullptr);
  }

  GamePlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GamePlayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GamePlayer& from);
  void MergeFrom(const GamePlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamePlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GamePlayer";
  }
  protected:
  explicit GamePlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIpAddressFieldNumber = 3,
    kIdFieldNumber = 2,
    kPortFieldNumber = 4,
    kRoleFieldNumber = 5,
    kTypeFieldNumber = 6,
    kScoreFieldNumber = 7,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string ip_address = 3;
  bool has_ip_address() const;
  private:
  bool _internal_has_ip_address() const;
  public:
  void clear_ip_address();
  const std::string& ip_address() const;
  void set_ip_address(const std::string& value);
  void set_ip_address(std::string&& value);
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  std::string* mutable_ip_address();
  std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ip_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip_address(
      std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // required int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 port = 4;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .snakes.NodeRole role = 5;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  ::snakes::NodeRole role() const;
  void set_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_role() const;
  void _internal_set_role(::snakes::NodeRole value);
  public:

  // optional .snakes.PlayerType type = 6 [default = HUMAN];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::snakes::PlayerType type() const;
  void set_type(::snakes::PlayerType value);
  private:
  ::snakes::PlayerType _internal_type() const;
  void _internal_set_type(::snakes::PlayerType value);
  public:

  // required int32 score = 7;
  bool has_score() const;
  private:
  bool _internal_has_score() const;
  public:
  void clear_score();
  ::PROTOBUF_NAMESPACE_ID::int32 score() const;
  void set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_score() const;
  void _internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GamePlayer)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  int role_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 score_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameConfig) */ {
 public:
  inline GameConfig() : GameConfig(nullptr) {};
  virtual ~GameConfig();

  GameConfig(const GameConfig& from);
  GameConfig(GameConfig&& from) noexcept
    : GameConfig() {
    *this = ::std::move(from);
  }

  inline GameConfig& operator=(const GameConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameConfig& operator=(GameConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameConfig* internal_default_instance() {
    return reinterpret_cast<const GameConfig*>(
               &_GameConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameConfig& a, GameConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GameConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameConfig* New() const final {
    return CreateMaybeMessage<GameConfig>(nullptr);
  }

  GameConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameConfig& from);
  void MergeFrom(const GameConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameConfig";
  }
  protected:
  explicit GameConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFoodStaticFieldNumber = 3,
    kStateDelayMsFieldNumber = 5,
  };
  // optional int32 width = 1 [default = 40];
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 height = 2 [default = 30];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 food_static = 3 [default = 1];
  bool has_food_static() const;
  private:
  bool _internal_has_food_static() const;
  public:
  void clear_food_static();
  ::PROTOBUF_NAMESPACE_ID::int32 food_static() const;
  void set_food_static(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_food_static() const;
  void _internal_set_food_static(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 state_delay_ms = 5 [default = 1000];
  bool has_state_delay_ms() const;
  private:
  bool _internal_has_state_delay_ms() const;
  public:
  void clear_state_delay_ms();
  ::PROTOBUF_NAMESPACE_ID::int32 state_delay_ms() const;
  void set_state_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state_delay_ms() const;
  void _internal_set_state_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 food_static_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_delay_ms_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GamePlayers PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GamePlayers) */ {
 public:
  inline GamePlayers() : GamePlayers(nullptr) {};
  virtual ~GamePlayers();

  GamePlayers(const GamePlayers& from);
  GamePlayers(GamePlayers&& from) noexcept
    : GamePlayers() {
    *this = ::std::move(from);
  }

  inline GamePlayers& operator=(const GamePlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamePlayers& operator=(GamePlayers&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GamePlayers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GamePlayers* internal_default_instance() {
    return reinterpret_cast<const GamePlayers*>(
               &_GamePlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GamePlayers& a, GamePlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(GamePlayers* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamePlayers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GamePlayers* New() const final {
    return CreateMaybeMessage<GamePlayers>(nullptr);
  }

  GamePlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GamePlayers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GamePlayers& from);
  void MergeFrom(const GamePlayers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamePlayers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GamePlayers";
  }
  protected:
  explicit GamePlayers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .snakes.GamePlayer players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::snakes::GamePlayer* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >*
      mutable_players();
  private:
  const ::snakes::GamePlayer& _internal_players(int index) const;
  ::snakes::GamePlayer* _internal_add_players();
  public:
  const ::snakes::GamePlayer& players(int index) const;
  ::snakes::GamePlayer* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >&
      players() const;

  // @@protoc_insertion_point(class_scope:snakes.GamePlayers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState_Coord PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Coord) */ {
 public:
  inline GameState_Coord() : GameState_Coord(nullptr) {};
  virtual ~GameState_Coord();

  GameState_Coord(const GameState_Coord& from);
  GameState_Coord(GameState_Coord&& from) noexcept
    : GameState_Coord() {
    *this = ::std::move(from);
  }

  inline GameState_Coord& operator=(const GameState_Coord& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState_Coord& operator=(GameState_Coord&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState_Coord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState_Coord* internal_default_instance() {
    return reinterpret_cast<const GameState_Coord*>(
               &_GameState_Coord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GameState_Coord& a, GameState_Coord& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState_Coord* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState_Coord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState_Coord* New() const final {
    return CreateMaybeMessage<GameState_Coord>(nullptr);
  }

  GameState_Coord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState_Coord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState_Coord& from);
  void MergeFrom(const GameState_Coord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState_Coord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState.Coord";
  }
  protected:
  explicit GameState_Coord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional sint32 x = 1 [default = 0];
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional sint32 y = 2 [default = 0];
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState.Coord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState_Snake PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState.Snake) */ {
 public:
  inline GameState_Snake() : GameState_Snake(nullptr) {};
  virtual ~GameState_Snake();

  GameState_Snake(const GameState_Snake& from);
  GameState_Snake(GameState_Snake&& from) noexcept
    : GameState_Snake() {
    *this = ::std::move(from);
  }

  inline GameState_Snake& operator=(const GameState_Snake& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState_Snake& operator=(GameState_Snake&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState_Snake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState_Snake* internal_default_instance() {
    return reinterpret_cast<const GameState_Snake*>(
               &_GameState_Snake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GameState_Snake& a, GameState_Snake& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState_Snake* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState_Snake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState_Snake* New() const final {
    return CreateMaybeMessage<GameState_Snake>(nullptr);
  }

  GameState_Snake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState_Snake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState_Snake& from);
  void MergeFrom(const GameState_Snake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState_Snake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState.Snake";
  }
  protected:
  explicit GameState_Snake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameState_Snake_SnakeState SnakeState;
  static constexpr SnakeState ALIVE =
    GameState_Snake_SnakeState_ALIVE;
  static constexpr SnakeState ZOMBIE =
    GameState_Snake_SnakeState_ZOMBIE;
  static inline bool SnakeState_IsValid(int value) {
    return GameState_Snake_SnakeState_IsValid(value);
  }
  static constexpr SnakeState SnakeState_MIN =
    GameState_Snake_SnakeState_SnakeState_MIN;
  static constexpr SnakeState SnakeState_MAX =
    GameState_Snake_SnakeState_SnakeState_MAX;
  static constexpr int SnakeState_ARRAYSIZE =
    GameState_Snake_SnakeState_SnakeState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SnakeState_descriptor() {
    return GameState_Snake_SnakeState_descriptor();
  }
  template<typename T>
  static inline const std::string& SnakeState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SnakeState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SnakeState_Name.");
    return GameState_Snake_SnakeState_Name(enum_t_value);
  }
  static inline bool SnakeState_Parse(const std::string& name,
      SnakeState* value) {
    return GameState_Snake_SnakeState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kStateFieldNumber = 3,
    kHeadDirectionFieldNumber = 4,
  };
  // repeated .snakes.GameState.Coord points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::snakes::GameState_Coord* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_points();
  private:
  const ::snakes::GameState_Coord& _internal_points(int index) const;
  ::snakes::GameState_Coord* _internal_add_points();
  public:
  const ::snakes::GameState_Coord& points(int index) const;
  ::snakes::GameState_Coord* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
      points() const;

  // required int32 player_id = 1;
  bool has_player_id() const;
  private:
  bool _internal_has_player_id() const;
  public:
  void clear_player_id();
  ::PROTOBUF_NAMESPACE_ID::int32 player_id() const;
  void set_player_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_player_id() const;
  void _internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::snakes::GameState_Snake_SnakeState state() const;
  void set_state(::snakes::GameState_Snake_SnakeState value);
  private:
  ::snakes::GameState_Snake_SnakeState _internal_state() const;
  void _internal_set_state(::snakes::GameState_Snake_SnakeState value);
  public:

  // required .snakes.Direction head_direction = 4;
  bool has_head_direction() const;
  private:
  bool _internal_has_head_direction() const;
  public:
  void clear_head_direction();
  ::snakes::Direction head_direction() const;
  void set_head_direction(::snakes::Direction value);
  private:
  ::snakes::Direction _internal_head_direction() const;
  void _internal_set_head_direction(::snakes::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState.Snake)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord > points_;
  ::PROTOBUF_NAMESPACE_ID::int32 player_id_;
  int state_;
  int head_direction_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameState) */ {
 public:
  inline GameState() : GameState(nullptr) {};
  virtual ~GameState();

  GameState(const GameState& from);
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }
  inline void Swap(GameState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(nullptr);
  }

  GameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameState";
  }
  protected:
  explicit GameState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameState_Coord Coord;
  typedef GameState_Snake Snake;

  // accessors -------------------------------------------------------

  enum : int {
    kSnakesFieldNumber = 2,
    kFoodsFieldNumber = 3,
    kPlayersFieldNumber = 4,
    kStateOrderFieldNumber = 1,
  };
  // repeated .snakes.GameState.Snake snakes = 2;
  int snakes_size() const;
  private:
  int _internal_snakes_size() const;
  public:
  void clear_snakes();
  ::snakes::GameState_Snake* mutable_snakes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >*
      mutable_snakes();
  private:
  const ::snakes::GameState_Snake& _internal_snakes(int index) const;
  ::snakes::GameState_Snake* _internal_add_snakes();
  public:
  const ::snakes::GameState_Snake& snakes(int index) const;
  ::snakes::GameState_Snake* add_snakes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >&
      snakes() const;

  // repeated .snakes.GameState.Coord foods = 3;
  int foods_size() const;
  private:
  int _internal_foods_size() const;
  public:
  void clear_foods();
  ::snakes::GameState_Coord* mutable_foods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
      mutable_foods();
  private:
  const ::snakes::GameState_Coord& _internal_foods(int index) const;
  ::snakes::GameState_Coord* _internal_add_foods();
  public:
  const ::snakes::GameState_Coord& foods(int index) const;
  ::snakes::GameState_Coord* add_foods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
      foods() const;

  // required .snakes.GamePlayers players = 4;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  const ::snakes::GamePlayers& players() const;
  ::snakes::GamePlayers* release_players();
  ::snakes::GamePlayers* mutable_players();
  void set_allocated_players(::snakes::GamePlayers* players);
  private:
  const ::snakes::GamePlayers& _internal_players() const;
  ::snakes::GamePlayers* _internal_mutable_players();
  public:
  void unsafe_arena_set_allocated_players(
      ::snakes::GamePlayers* players);
  ::snakes::GamePlayers* unsafe_arena_release_players();

  // required int32 state_order = 1;
  bool has_state_order() const;
  private:
  bool _internal_has_state_order() const;
  public:
  void clear_state_order();
  ::PROTOBUF_NAMESPACE_ID::int32 state_order() const;
  void set_state_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_state_order() const;
  void _internal_set_state_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake > snakes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord > foods_;
  ::snakes::GamePlayers* players_;
  ::PROTOBUF_NAMESPACE_ID::int32 state_order_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameAnnouncement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameAnnouncement) */ {
 public:
  inline GameAnnouncement() : GameAnnouncement(nullptr) {};
  virtual ~GameAnnouncement();

  GameAnnouncement(const GameAnnouncement& from);
  GameAnnouncement(GameAnnouncement&& from) noexcept
    : GameAnnouncement() {
    *this = ::std::move(from);
  }

  inline GameAnnouncement& operator=(const GameAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAnnouncement& operator=(GameAnnouncement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameAnnouncement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameAnnouncement* internal_default_instance() {
    return reinterpret_cast<const GameAnnouncement*>(
               &_GameAnnouncement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameAnnouncement& a, GameAnnouncement& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAnnouncement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameAnnouncement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameAnnouncement* New() const final {
    return CreateMaybeMessage<GameAnnouncement>(nullptr);
  }

  GameAnnouncement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameAnnouncement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameAnnouncement& from);
  void MergeFrom(const GameAnnouncement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAnnouncement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameAnnouncement";
  }
  protected:
  explicit GameAnnouncement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 4,
    kPlayersFieldNumber = 1,
    kConfigFieldNumber = 2,
    kCanJoinFieldNumber = 3,
  };
  // required string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  void set_game_name(const std::string& value);
  void set_game_name(std::string&& value);
  void set_game_name(const char* value);
  void set_game_name(const char* value, size_t size);
  std::string* mutable_game_name();
  std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_game_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_game_name(
      std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // required .snakes.GamePlayers players = 1;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  const ::snakes::GamePlayers& players() const;
  ::snakes::GamePlayers* release_players();
  ::snakes::GamePlayers* mutable_players();
  void set_allocated_players(::snakes::GamePlayers* players);
  private:
  const ::snakes::GamePlayers& _internal_players() const;
  ::snakes::GamePlayers* _internal_mutable_players();
  public:
  void unsafe_arena_set_allocated_players(
      ::snakes::GamePlayers* players);
  ::snakes::GamePlayers* unsafe_arena_release_players();

  // required .snakes.GameConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::snakes::GameConfig& config() const;
  ::snakes::GameConfig* release_config();
  ::snakes::GameConfig* mutable_config();
  void set_allocated_config(::snakes::GameConfig* config);
  private:
  const ::snakes::GameConfig& _internal_config() const;
  ::snakes::GameConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::snakes::GameConfig* config);
  ::snakes::GameConfig* unsafe_arena_release_config();

  // optional bool can_join = 3 [default = true];
  bool has_can_join() const;
  private:
  bool _internal_has_can_join() const;
  public:
  void clear_can_join();
  bool can_join() const;
  void set_can_join(bool value);
  private:
  bool _internal_can_join() const;
  void _internal_set_can_join(bool value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameAnnouncement)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  ::snakes::GamePlayers* players_;
  ::snakes::GameConfig* config_;
  bool can_join_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_PingMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.PingMsg) */ {
 public:
  inline GameMessage_PingMsg() : GameMessage_PingMsg(nullptr) {};
  virtual ~GameMessage_PingMsg();

  GameMessage_PingMsg(const GameMessage_PingMsg& from);
  GameMessage_PingMsg(GameMessage_PingMsg&& from) noexcept
    : GameMessage_PingMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_PingMsg& operator=(const GameMessage_PingMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_PingMsg& operator=(GameMessage_PingMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_PingMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_PingMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_PingMsg*>(
               &_GameMessage_PingMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GameMessage_PingMsg& a, GameMessage_PingMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_PingMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_PingMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_PingMsg* New() const final {
    return CreateMaybeMessage<GameMessage_PingMsg>(nullptr);
  }

  GameMessage_PingMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_PingMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_PingMsg& from);
  void MergeFrom(const GameMessage_PingMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_PingMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.PingMsg";
  }
  protected:
  explicit GameMessage_PingMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.PingMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_SteerMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.SteerMsg) */ {
 public:
  inline GameMessage_SteerMsg() : GameMessage_SteerMsg(nullptr) {};
  virtual ~GameMessage_SteerMsg();

  GameMessage_SteerMsg(const GameMessage_SteerMsg& from);
  GameMessage_SteerMsg(GameMessage_SteerMsg&& from) noexcept
    : GameMessage_SteerMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_SteerMsg& operator=(const GameMessage_SteerMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_SteerMsg& operator=(GameMessage_SteerMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_SteerMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_SteerMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_SteerMsg*>(
               &_GameMessage_SteerMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GameMessage_SteerMsg& a, GameMessage_SteerMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_SteerMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_SteerMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_SteerMsg* New() const final {
    return CreateMaybeMessage<GameMessage_SteerMsg>(nullptr);
  }

  GameMessage_SteerMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_SteerMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_SteerMsg& from);
  void MergeFrom(const GameMessage_SteerMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_SteerMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.SteerMsg";
  }
  protected:
  explicit GameMessage_SteerMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
  };
  // required .snakes.Direction direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::snakes::Direction direction() const;
  void set_direction(::snakes::Direction value);
  private:
  ::snakes::Direction _internal_direction() const;
  void _internal_set_direction(::snakes::Direction value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.SteerMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int direction_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_AckMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AckMsg) */ {
 public:
  inline GameMessage_AckMsg() : GameMessage_AckMsg(nullptr) {};
  virtual ~GameMessage_AckMsg();

  GameMessage_AckMsg(const GameMessage_AckMsg& from);
  GameMessage_AckMsg(GameMessage_AckMsg&& from) noexcept
    : GameMessage_AckMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_AckMsg& operator=(const GameMessage_AckMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_AckMsg& operator=(GameMessage_AckMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_AckMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_AckMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_AckMsg*>(
               &_GameMessage_AckMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GameMessage_AckMsg& a, GameMessage_AckMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_AckMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_AckMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_AckMsg* New() const final {
    return CreateMaybeMessage<GameMessage_AckMsg>(nullptr);
  }

  GameMessage_AckMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_AckMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_AckMsg& from);
  void MergeFrom(const GameMessage_AckMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_AckMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.AckMsg";
  }
  protected:
  explicit GameMessage_AckMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AckMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_StateMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.StateMsg) */ {
 public:
  inline GameMessage_StateMsg() : GameMessage_StateMsg(nullptr) {};
  virtual ~GameMessage_StateMsg();

  GameMessage_StateMsg(const GameMessage_StateMsg& from);
  GameMessage_StateMsg(GameMessage_StateMsg&& from) noexcept
    : GameMessage_StateMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_StateMsg& operator=(const GameMessage_StateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_StateMsg& operator=(GameMessage_StateMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_StateMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_StateMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_StateMsg*>(
               &_GameMessage_StateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GameMessage_StateMsg& a, GameMessage_StateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_StateMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_StateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_StateMsg* New() const final {
    return CreateMaybeMessage<GameMessage_StateMsg>(nullptr);
  }

  GameMessage_StateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_StateMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_StateMsg& from);
  void MergeFrom(const GameMessage_StateMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_StateMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.StateMsg";
  }
  protected:
  explicit GameMessage_StateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .snakes.GameState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::snakes::GameState& state() const;
  ::snakes::GameState* release_state();
  ::snakes::GameState* mutable_state();
  void set_allocated_state(::snakes::GameState* state);
  private:
  const ::snakes::GameState& _internal_state() const;
  ::snakes::GameState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::snakes::GameState* state);
  ::snakes::GameState* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.StateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::snakes::GameState* state_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_AnnouncementMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.AnnouncementMsg) */ {
 public:
  inline GameMessage_AnnouncementMsg() : GameMessage_AnnouncementMsg(nullptr) {};
  virtual ~GameMessage_AnnouncementMsg();

  GameMessage_AnnouncementMsg(const GameMessage_AnnouncementMsg& from);
  GameMessage_AnnouncementMsg(GameMessage_AnnouncementMsg&& from) noexcept
    : GameMessage_AnnouncementMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_AnnouncementMsg& operator=(const GameMessage_AnnouncementMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_AnnouncementMsg& operator=(GameMessage_AnnouncementMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_AnnouncementMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_AnnouncementMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_AnnouncementMsg*>(
               &_GameMessage_AnnouncementMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GameMessage_AnnouncementMsg& a, GameMessage_AnnouncementMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_AnnouncementMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_AnnouncementMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_AnnouncementMsg* New() const final {
    return CreateMaybeMessage<GameMessage_AnnouncementMsg>(nullptr);
  }

  GameMessage_AnnouncementMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_AnnouncementMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_AnnouncementMsg& from);
  void MergeFrom(const GameMessage_AnnouncementMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_AnnouncementMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.AnnouncementMsg";
  }
  protected:
  explicit GameMessage_AnnouncementMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamesFieldNumber = 1,
  };
  // repeated .snakes.GameAnnouncement games = 1;
  int games_size() const;
  private:
  int _internal_games_size() const;
  public:
  void clear_games();
  ::snakes::GameAnnouncement* mutable_games(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >*
      mutable_games();
  private:
  const ::snakes::GameAnnouncement& _internal_games(int index) const;
  ::snakes::GameAnnouncement* _internal_add_games();
  public:
  const ::snakes::GameAnnouncement& games(int index) const;
  ::snakes::GameAnnouncement* add_games();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >&
      games() const;

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.AnnouncementMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement > games_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_DiscoverMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.DiscoverMsg) */ {
 public:
  inline GameMessage_DiscoverMsg() : GameMessage_DiscoverMsg(nullptr) {};
  virtual ~GameMessage_DiscoverMsg();

  GameMessage_DiscoverMsg(const GameMessage_DiscoverMsg& from);
  GameMessage_DiscoverMsg(GameMessage_DiscoverMsg&& from) noexcept
    : GameMessage_DiscoverMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_DiscoverMsg& operator=(const GameMessage_DiscoverMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_DiscoverMsg& operator=(GameMessage_DiscoverMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_DiscoverMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_DiscoverMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_DiscoverMsg*>(
               &_GameMessage_DiscoverMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GameMessage_DiscoverMsg& a, GameMessage_DiscoverMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_DiscoverMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_DiscoverMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_DiscoverMsg* New() const final {
    return CreateMaybeMessage<GameMessage_DiscoverMsg>(nullptr);
  }

  GameMessage_DiscoverMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_DiscoverMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_DiscoverMsg& from);
  void MergeFrom(const GameMessage_DiscoverMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_DiscoverMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.DiscoverMsg";
  }
  protected:
  explicit GameMessage_DiscoverMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.DiscoverMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_JoinMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.JoinMsg) */ {
 public:
  inline GameMessage_JoinMsg() : GameMessage_JoinMsg(nullptr) {};
  virtual ~GameMessage_JoinMsg();

  GameMessage_JoinMsg(const GameMessage_JoinMsg& from);
  GameMessage_JoinMsg(GameMessage_JoinMsg&& from) noexcept
    : GameMessage_JoinMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_JoinMsg& operator=(const GameMessage_JoinMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_JoinMsg& operator=(GameMessage_JoinMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_JoinMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_JoinMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_JoinMsg*>(
               &_GameMessage_JoinMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GameMessage_JoinMsg& a, GameMessage_JoinMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_JoinMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_JoinMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_JoinMsg* New() const final {
    return CreateMaybeMessage<GameMessage_JoinMsg>(nullptr);
  }

  GameMessage_JoinMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_JoinMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_JoinMsg& from);
  void MergeFrom(const GameMessage_JoinMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_JoinMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.JoinMsg";
  }
  protected:
  explicit GameMessage_JoinMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 3,
    kGameNameFieldNumber = 4,
    kPlayerTypeFieldNumber = 1,
    kRequestedRoleFieldNumber = 5,
  };
  // required string player_name = 3;
  bool has_player_name() const;
  private:
  bool _internal_has_player_name() const;
  public:
  void clear_player_name();
  const std::string& player_name() const;
  void set_player_name(const std::string& value);
  void set_player_name(std::string&& value);
  void set_player_name(const char* value);
  void set_player_name(const char* value, size_t size);
  std::string* mutable_player_name();
  std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_player_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_player_name(
      std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // required string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  void set_game_name(const std::string& value);
  void set_game_name(std::string&& value);
  void set_game_name(const char* value);
  void set_game_name(const char* value, size_t size);
  std::string* mutable_game_name();
  std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_game_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_game_name(
      std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional .snakes.PlayerType player_type = 1 [default = HUMAN];
  bool has_player_type() const;
  private:
  bool _internal_has_player_type() const;
  public:
  void clear_player_type();
  ::snakes::PlayerType player_type() const;
  void set_player_type(::snakes::PlayerType value);
  private:
  ::snakes::PlayerType _internal_player_type() const;
  void _internal_set_player_type(::snakes::PlayerType value);
  public:

  // required .snakes.NodeRole requested_role = 5;
  bool has_requested_role() const;
  private:
  bool _internal_has_requested_role() const;
  public:
  void clear_requested_role();
  ::snakes::NodeRole requested_role() const;
  void set_requested_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_requested_role() const;
  void _internal_set_requested_role(::snakes::NodeRole value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.JoinMsg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  int player_type_;
  int requested_role_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_ErrorMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.ErrorMsg) */ {
 public:
  inline GameMessage_ErrorMsg() : GameMessage_ErrorMsg(nullptr) {};
  virtual ~GameMessage_ErrorMsg();

  GameMessage_ErrorMsg(const GameMessage_ErrorMsg& from);
  GameMessage_ErrorMsg(GameMessage_ErrorMsg&& from) noexcept
    : GameMessage_ErrorMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_ErrorMsg& operator=(const GameMessage_ErrorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_ErrorMsg& operator=(GameMessage_ErrorMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_ErrorMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_ErrorMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_ErrorMsg*>(
               &_GameMessage_ErrorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GameMessage_ErrorMsg& a, GameMessage_ErrorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_ErrorMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_ErrorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_ErrorMsg* New() const final {
    return CreateMaybeMessage<GameMessage_ErrorMsg>(nullptr);
  }

  GameMessage_ErrorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_ErrorMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_ErrorMsg& from);
  void MergeFrom(const GameMessage_ErrorMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_ErrorMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.ErrorMsg";
  }
  protected:
  explicit GameMessage_ErrorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // required string error_message = 1;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  void set_error_message(const std::string& value);
  void set_error_message(std::string&& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  std::string* mutable_error_message();
  std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error_message(
      std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.ErrorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage_RoleChangeMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage.RoleChangeMsg) */ {
 public:
  inline GameMessage_RoleChangeMsg() : GameMessage_RoleChangeMsg(nullptr) {};
  virtual ~GameMessage_RoleChangeMsg();

  GameMessage_RoleChangeMsg(const GameMessage_RoleChangeMsg& from);
  GameMessage_RoleChangeMsg(GameMessage_RoleChangeMsg&& from) noexcept
    : GameMessage_RoleChangeMsg() {
    *this = ::std::move(from);
  }

  inline GameMessage_RoleChangeMsg& operator=(const GameMessage_RoleChangeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage_RoleChangeMsg& operator=(GameMessage_RoleChangeMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage_RoleChangeMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage_RoleChangeMsg* internal_default_instance() {
    return reinterpret_cast<const GameMessage_RoleChangeMsg*>(
               &_GameMessage_RoleChangeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameMessage_RoleChangeMsg& a, GameMessage_RoleChangeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage_RoleChangeMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage_RoleChangeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage_RoleChangeMsg* New() const final {
    return CreateMaybeMessage<GameMessage_RoleChangeMsg>(nullptr);
  }

  GameMessage_RoleChangeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage_RoleChangeMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage_RoleChangeMsg& from);
  void MergeFrom(const GameMessage_RoleChangeMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage_RoleChangeMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage.RoleChangeMsg";
  }
  protected:
  explicit GameMessage_RoleChangeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderRoleFieldNumber = 1,
    kReceiverRoleFieldNumber = 2,
  };
  // optional .snakes.NodeRole sender_role = 1;
  bool has_sender_role() const;
  private:
  bool _internal_has_sender_role() const;
  public:
  void clear_sender_role();
  ::snakes::NodeRole sender_role() const;
  void set_sender_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_sender_role() const;
  void _internal_set_sender_role(::snakes::NodeRole value);
  public:

  // optional .snakes.NodeRole receiver_role = 2;
  bool has_receiver_role() const;
  private:
  bool _internal_has_receiver_role() const;
  public:
  void clear_receiver_role();
  ::snakes::NodeRole receiver_role() const;
  void set_receiver_role(::snakes::NodeRole value);
  private:
  ::snakes::NodeRole _internal_receiver_role() const;
  void _internal_set_receiver_role(::snakes::NodeRole value);
  public:

  // @@protoc_insertion_point(class_scope:snakes.GameMessage.RoleChangeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int sender_role_;
  int receiver_role_;
  friend struct ::TableStruct_snakes_2eproto;
};
// -------------------------------------------------------------------

class GameMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:snakes.GameMessage) */ {
 public:
  inline GameMessage() : GameMessage(nullptr) {};
  virtual ~GameMessage();

  GameMessage(const GameMessage& from);
  GameMessage(GameMessage&& from) noexcept
    : GameMessage() {
    *this = ::std::move(from);
  }

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage& operator=(GameMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMessage& default_instance();

  enum TypeCase {
    kPing = 2,
    kSteer = 3,
    kAck = 4,
    kState = 5,
    kAnnouncement = 6,
    kJoin = 7,
    kError = 8,
    kRoleChange = 9,
    kDiscover = 12,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMessage* internal_default_instance() {
    return reinterpret_cast<const GameMessage*>(
               &_GameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameMessage& a, GameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMessage* New() const final {
    return CreateMaybeMessage<GameMessage>(nullptr);
  }

  GameMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMessage& from);
  void MergeFrom(const GameMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "snakes.GameMessage";
  }
  protected:
  explicit GameMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_snakes_2eproto);
    return ::descriptor_table_snakes_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameMessage_PingMsg PingMsg;
  typedef GameMessage_SteerMsg SteerMsg;
  typedef GameMessage_AckMsg AckMsg;
  typedef GameMessage_StateMsg StateMsg;
  typedef GameMessage_AnnouncementMsg AnnouncementMsg;
  typedef GameMessage_DiscoverMsg DiscoverMsg;
  typedef GameMessage_JoinMsg JoinMsg;
  typedef GameMessage_ErrorMsg ErrorMsg;
  typedef GameMessage_RoleChangeMsg RoleChangeMsg;

  // accessors -------------------------------------------------------

  enum : int {
    kMsgSeqFieldNumber = 1,
    kSenderIdFieldNumber = 10,
    kReceiverIdFieldNumber = 11,
    kPingFieldNumber = 2,
    kSteerFieldNumber = 3,
    kAckFieldNumber = 4,
    kStateFieldNumber = 5,
    kAnnouncementFieldNumber = 6,
    kJoinFieldNumber = 7,
    kErrorFieldNumber = 8,
    kRoleChangeFieldNumber = 9,
    kDiscoverFieldNumber = 12,
  };
  // required int64 msg_seq = 1;
  bool has_msg_seq() const;
  private:
  bool _internal_has_msg_seq() const;
  public:
  void clear_msg_seq();
  ::PROTOBUF_NAMESPACE_ID::int64 msg_seq() const;
  void set_msg_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_msg_seq() const;
  void _internal_set_msg_seq(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 sender_id = 10;
  bool has_sender_id() const;
  private:
  bool _internal_has_sender_id() const;
  public:
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 receiver_id = 11;
  bool has_receiver_id() const;
  private:
  bool _internal_has_receiver_id() const;
  public:
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .snakes.GameMessage.PingMsg ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::snakes::GameMessage_PingMsg& ping() const;
  ::snakes::GameMessage_PingMsg* release_ping();
  ::snakes::GameMessage_PingMsg* mutable_ping();
  void set_allocated_ping(::snakes::GameMessage_PingMsg* ping);
  private:
  const ::snakes::GameMessage_PingMsg& _internal_ping() const;
  ::snakes::GameMessage_PingMsg* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::snakes::GameMessage_PingMsg* ping);
  ::snakes::GameMessage_PingMsg* unsafe_arena_release_ping();

  // .snakes.GameMessage.SteerMsg steer = 3;
  bool has_steer() const;
  private:
  bool _internal_has_steer() const;
  public:
  void clear_steer();
  const ::snakes::GameMessage_SteerMsg& steer() const;
  ::snakes::GameMessage_SteerMsg* release_steer();
  ::snakes::GameMessage_SteerMsg* mutable_steer();
  void set_allocated_steer(::snakes::GameMessage_SteerMsg* steer);
  private:
  const ::snakes::GameMessage_SteerMsg& _internal_steer() const;
  ::snakes::GameMessage_SteerMsg* _internal_mutable_steer();
  public:
  void unsafe_arena_set_allocated_steer(
      ::snakes::GameMessage_SteerMsg* steer);
  ::snakes::GameMessage_SteerMsg* unsafe_arena_release_steer();

  // .snakes.GameMessage.AckMsg ack = 4;
  bool has_ack() const;
  private:
  bool _internal_has_ack() const;
  public:
  void clear_ack();
  const ::snakes::GameMessage_AckMsg& ack() const;
  ::snakes::GameMessage_AckMsg* release_ack();
  ::snakes::GameMessage_AckMsg* mutable_ack();
  void set_allocated_ack(::snakes::GameMessage_AckMsg* ack);
  private:
  const ::snakes::GameMessage_AckMsg& _internal_ack() const;
  ::snakes::GameMessage_AckMsg* _internal_mutable_ack();
  public:
  void unsafe_arena_set_allocated_ack(
      ::snakes::GameMessage_AckMsg* ack);
  ::snakes::GameMessage_AckMsg* unsafe_arena_release_ack();

  // .snakes.GameMessage.StateMsg state = 5;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::snakes::GameMessage_StateMsg& state() const;
  ::snakes::GameMessage_StateMsg* release_state();
  ::snakes::GameMessage_StateMsg* mutable_state();
  void set_allocated_state(::snakes::GameMessage_StateMsg* state);
  private:
  const ::snakes::GameMessage_StateMsg& _internal_state() const;
  ::snakes::GameMessage_StateMsg* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::snakes::GameMessage_StateMsg* state);
  ::snakes::GameMessage_StateMsg* unsafe_arena_release_state();

  // .snakes.GameMessage.AnnouncementMsg announcement = 6;
  bool has_announcement() const;
  private:
  bool _internal_has_announcement() const;
  public:
  void clear_announcement();
  const ::snakes::GameMessage_AnnouncementMsg& announcement() const;
  ::snakes::GameMessage_AnnouncementMsg* release_announcement();
  ::snakes::GameMessage_AnnouncementMsg* mutable_announcement();
  void set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement);
  private:
  const ::snakes::GameMessage_AnnouncementMsg& _internal_announcement() const;
  ::snakes::GameMessage_AnnouncementMsg* _internal_mutable_announcement();
  public:
  void unsafe_arena_set_allocated_announcement(
      ::snakes::GameMessage_AnnouncementMsg* announcement);
  ::snakes::GameMessage_AnnouncementMsg* unsafe_arena_release_announcement();

  // .snakes.GameMessage.JoinMsg join = 7;
  bool has_join() const;
  private:
  bool _internal_has_join() const;
  public:
  void clear_join();
  const ::snakes::GameMessage_JoinMsg& join() const;
  ::snakes::GameMessage_JoinMsg* release_join();
  ::snakes::GameMessage_JoinMsg* mutable_join();
  void set_allocated_join(::snakes::GameMessage_JoinMsg* join);
  private:
  const ::snakes::GameMessage_JoinMsg& _internal_join() const;
  ::snakes::GameMessage_JoinMsg* _internal_mutable_join();
  public:
  void unsafe_arena_set_allocated_join(
      ::snakes::GameMessage_JoinMsg* join);
  ::snakes::GameMessage_JoinMsg* unsafe_arena_release_join();

  // .snakes.GameMessage.ErrorMsg error = 8;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::snakes::GameMessage_ErrorMsg& error() const;
  ::snakes::GameMessage_ErrorMsg* release_error();
  ::snakes::GameMessage_ErrorMsg* mutable_error();
  void set_allocated_error(::snakes::GameMessage_ErrorMsg* error);
  private:
  const ::snakes::GameMessage_ErrorMsg& _internal_error() const;
  ::snakes::GameMessage_ErrorMsg* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::snakes::GameMessage_ErrorMsg* error);
  ::snakes::GameMessage_ErrorMsg* unsafe_arena_release_error();

  // .snakes.GameMessage.RoleChangeMsg role_change = 9;
  bool has_role_change() const;
  private:
  bool _internal_has_role_change() const;
  public:
  void clear_role_change();
  const ::snakes::GameMessage_RoleChangeMsg& role_change() const;
  ::snakes::GameMessage_RoleChangeMsg* release_role_change();
  ::snakes::GameMessage_RoleChangeMsg* mutable_role_change();
  void set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change);
  private:
  const ::snakes::GameMessage_RoleChangeMsg& _internal_role_change() const;
  ::snakes::GameMessage_RoleChangeMsg* _internal_mutable_role_change();
  public:
  void unsafe_arena_set_allocated_role_change(
      ::snakes::GameMessage_RoleChangeMsg* role_change);
  ::snakes::GameMessage_RoleChangeMsg* unsafe_arena_release_role_change();

  // .snakes.GameMessage.DiscoverMsg discover = 12;
  bool has_discover() const;
  private:
  bool _internal_has_discover() const;
  public:
  void clear_discover();
  const ::snakes::GameMessage_DiscoverMsg& discover() const;
  ::snakes::GameMessage_DiscoverMsg* release_discover();
  ::snakes::GameMessage_DiscoverMsg* mutable_discover();
  void set_allocated_discover(::snakes::GameMessage_DiscoverMsg* discover);
  private:
  const ::snakes::GameMessage_DiscoverMsg& _internal_discover() const;
  ::snakes::GameMessage_DiscoverMsg* _internal_mutable_discover();
  public:
  void unsafe_arena_set_allocated_discover(
      ::snakes::GameMessage_DiscoverMsg* discover);
  ::snakes::GameMessage_DiscoverMsg* unsafe_arena_release_discover();

  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:snakes.GameMessage)
 private:
  class _Internal;
  void set_has_ping();
  void set_has_steer();
  void set_has_ack();
  void set_has_state();
  void set_has_announcement();
  void set_has_join();
  void set_has_error();
  void set_has_role_change();
  void set_has_discover();

  inline bool has_Type() const;
  inline void clear_has_Type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 msg_seq_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  union TypeUnion {
    TypeUnion() {}
    ::snakes::GameMessage_PingMsg* ping_;
    ::snakes::GameMessage_SteerMsg* steer_;
    ::snakes::GameMessage_AckMsg* ack_;
    ::snakes::GameMessage_StateMsg* state_;
    ::snakes::GameMessage_AnnouncementMsg* announcement_;
    ::snakes::GameMessage_JoinMsg* join_;
    ::snakes::GameMessage_ErrorMsg* error_;
    ::snakes::GameMessage_RoleChangeMsg* role_change_;
    ::snakes::GameMessage_DiscoverMsg* discover_;
  } Type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_snakes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GamePlayer

// required string name = 1;
inline bool GamePlayer::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GamePlayer::has_name() const {
  return _internal_has_name();
}
inline void GamePlayer::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GamePlayer::name() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.name)
  return _internal_name();
}
inline void GamePlayer::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.name)
}
inline std::string* GamePlayer::mutable_name() {
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.name)
  return _internal_mutable_name();
}
inline const std::string& GamePlayer::_internal_name() const {
  return name_.Get();
}
inline void GamePlayer::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GamePlayer::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GamePlayer.name)
}
inline void GamePlayer::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GamePlayer.name)
}
inline void GamePlayer::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GamePlayer.name)
}
inline std::string* GamePlayer::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GamePlayer::release_name() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GamePlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.name)
}
inline std::string* GamePlayer::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GamePlayer.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GamePlayer::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GamePlayer.name)
}

// required int32 id = 2;
inline bool GamePlayer::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GamePlayer::has_id() const {
  return _internal_has_id();
}
inline void GamePlayer::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::id() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.id)
  return _internal_id();
}
inline void GamePlayer::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void GamePlayer::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.id)
}

// optional string ip_address = 3;
inline bool GamePlayer::_internal_has_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GamePlayer::has_ip_address() const {
  return _internal_has_ip_address();
}
inline void GamePlayer::clear_ip_address() {
  ip_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GamePlayer::ip_address() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.ip_address)
  return _internal_ip_address();
}
inline void GamePlayer::set_ip_address(const std::string& value) {
  _internal_set_ip_address(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.ip_address)
}
inline std::string* GamePlayer::mutable_ip_address() {
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayer.ip_address)
  return _internal_mutable_ip_address();
}
inline const std::string& GamePlayer::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void GamePlayer::_internal_set_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GamePlayer::set_ip_address(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GamePlayer.ip_address)
}
inline void GamePlayer::set_ip_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GamePlayer.ip_address)
}
inline void GamePlayer::set_ip_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GamePlayer.ip_address)
}
inline std::string* GamePlayer::_internal_mutable_ip_address() {
  _has_bits_[0] |= 0x00000002u;
  return ip_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GamePlayer::release_ip_address() {
  // @@protoc_insertion_point(field_release:snakes.GamePlayer.ip_address)
  if (!_internal_has_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GamePlayer::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GamePlayer.ip_address)
}
inline std::string* GamePlayer::unsafe_arena_release_ip_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GamePlayer.ip_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ip_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GamePlayer::unsafe_arena_set_allocated_ip_address(
    std::string* ip_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ip_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GamePlayer.ip_address)
}

// optional int32 port = 4;
inline bool GamePlayer::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GamePlayer::has_port() const {
  return _internal_has_port();
}
inline void GamePlayer::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::port() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.port)
  return _internal_port();
}
inline void GamePlayer::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  port_ = value;
}
inline void GamePlayer::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.port)
}

// required .snakes.NodeRole role = 5;
inline bool GamePlayer::_internal_has_role() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GamePlayer::has_role() const {
  return _internal_has_role();
}
inline void GamePlayer::clear_role() {
  role_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::snakes::NodeRole GamePlayer::_internal_role() const {
  return static_cast< ::snakes::NodeRole >(role_);
}
inline ::snakes::NodeRole GamePlayer::role() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.role)
  return _internal_role();
}
inline void GamePlayer::_internal_set_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  role_ = value;
}
inline void GamePlayer::set_role(::snakes::NodeRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.role)
}

// optional .snakes.PlayerType type = 6 [default = HUMAN];
inline bool GamePlayer::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GamePlayer::has_type() const {
  return _internal_has_type();
}
inline void GamePlayer::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::snakes::PlayerType GamePlayer::_internal_type() const {
  return static_cast< ::snakes::PlayerType >(type_);
}
inline ::snakes::PlayerType GamePlayer::type() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.type)
  return _internal_type();
}
inline void GamePlayer::_internal_set_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void GamePlayer::set_type(::snakes::PlayerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.type)
}

// required int32 score = 7;
inline bool GamePlayer::_internal_has_score() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GamePlayer::has_score() const {
  return _internal_has_score();
}
inline void GamePlayer::clear_score() {
  score_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::_internal_score() const {
  return score_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GamePlayer::score() const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayer.score)
  return _internal_score();
}
inline void GamePlayer::_internal_set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  score_ = value;
}
inline void GamePlayer::set_score(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:snakes.GamePlayer.score)
}

// -------------------------------------------------------------------

// GameConfig

// optional int32 width = 1 [default = 40];
inline bool GameConfig::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameConfig::has_width() const {
  return _internal_has_width();
}
inline void GameConfig::clear_width() {
  width_ = 40;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::width() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.width)
  return _internal_width();
}
inline void GameConfig::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void GameConfig::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.width)
}

// optional int32 height = 2 [default = 30];
inline bool GameConfig::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameConfig::has_height() const {
  return _internal_has_height();
}
inline void GameConfig::clear_height() {
  height_ = 30;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::height() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.height)
  return _internal_height();
}
inline void GameConfig::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void GameConfig::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.height)
}

// optional int32 food_static = 3 [default = 1];
inline bool GameConfig::_internal_has_food_static() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameConfig::has_food_static() const {
  return _internal_has_food_static();
}
inline void GameConfig::clear_food_static() {
  food_static_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::_internal_food_static() const {
  return food_static_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::food_static() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.food_static)
  return _internal_food_static();
}
inline void GameConfig::_internal_set_food_static(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  food_static_ = value;
}
inline void GameConfig::set_food_static(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_food_static(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.food_static)
}

// optional int32 state_delay_ms = 5 [default = 1000];
inline bool GameConfig::_internal_has_state_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameConfig::has_state_delay_ms() const {
  return _internal_has_state_delay_ms();
}
inline void GameConfig::clear_state_delay_ms() {
  state_delay_ms_ = 1000;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::_internal_state_delay_ms() const {
  return state_delay_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameConfig::state_delay_ms() const {
  // @@protoc_insertion_point(field_get:snakes.GameConfig.state_delay_ms)
  return _internal_state_delay_ms();
}
inline void GameConfig::_internal_set_state_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  state_delay_ms_ = value;
}
inline void GameConfig::set_state_delay_ms(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state_delay_ms(value);
  // @@protoc_insertion_point(field_set:snakes.GameConfig.state_delay_ms)
}

// -------------------------------------------------------------------

// GamePlayers

// repeated .snakes.GamePlayer players = 1;
inline int GamePlayers::_internal_players_size() const {
  return players_.size();
}
inline int GamePlayers::players_size() const {
  return _internal_players_size();
}
inline void GamePlayers::clear_players() {
  players_.Clear();
}
inline ::snakes::GamePlayer* GamePlayers::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GamePlayers.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >*
GamePlayers::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GamePlayers.players)
  return &players_;
}
inline const ::snakes::GamePlayer& GamePlayers::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::snakes::GamePlayer& GamePlayers::players(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GamePlayers.players)
  return _internal_players(index);
}
inline ::snakes::GamePlayer* GamePlayers::_internal_add_players() {
  return players_.Add();
}
inline ::snakes::GamePlayer* GamePlayers::add_players() {
  // @@protoc_insertion_point(field_add:snakes.GamePlayers.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GamePlayer >&
GamePlayers::players() const {
  // @@protoc_insertion_point(field_list:snakes.GamePlayers.players)
  return players_;
}

// -------------------------------------------------------------------

// GameState_Coord

// optional sint32 x = 1 [default = 0];
inline bool GameState_Coord::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameState_Coord::has_x() const {
  return _internal_has_x();
}
inline void GameState_Coord::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Coord::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Coord::x() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.x)
  return _internal_x();
}
inline void GameState_Coord::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void GameState_Coord::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.x)
}

// optional sint32 y = 2 [default = 0];
inline bool GameState_Coord::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState_Coord::has_y() const {
  return _internal_has_y();
}
inline void GameState_Coord::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Coord::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Coord::y() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Coord.y)
  return _internal_y();
}
inline void GameState_Coord::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void GameState_Coord::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Coord.y)
}

// -------------------------------------------------------------------

// GameState_Snake

// required int32 player_id = 1;
inline bool GameState_Snake::_internal_has_player_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameState_Snake::has_player_id() const {
  return _internal_has_player_id();
}
inline void GameState_Snake::clear_player_id() {
  player_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Snake::_internal_player_id() const {
  return player_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState_Snake::player_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.player_id)
  return _internal_player_id();
}
inline void GameState_Snake::_internal_set_player_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  player_id_ = value;
}
inline void GameState_Snake::set_player_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.player_id)
}

// repeated .snakes.GameState.Coord points = 2;
inline int GameState_Snake::_internal_points_size() const {
  return points_.size();
}
inline int GameState_Snake::points_size() const {
  return _internal_points_size();
}
inline void GameState_Snake::clear_points() {
  points_.Clear();
}
inline ::snakes::GameState_Coord* GameState_Snake::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.Snake.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState_Snake::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.Snake.points)
  return &points_;
}
inline const ::snakes::GameState_Coord& GameState_Snake::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::snakes::GameState_Coord& GameState_Snake::points(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.points)
  return _internal_points(index);
}
inline ::snakes::GameState_Coord* GameState_Snake::_internal_add_points() {
  return points_.Add();
}
inline ::snakes::GameState_Coord* GameState_Snake::add_points() {
  // @@protoc_insertion_point(field_add:snakes.GameState.Snake.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState_Snake::points() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.Snake.points)
  return points_;
}

// required .snakes.GameState.Snake.SnakeState state = 3 [default = ALIVE];
inline bool GameState_Snake::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState_Snake::has_state() const {
  return _internal_has_state();
}
inline void GameState_Snake::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::snakes::GameState_Snake_SnakeState GameState_Snake::_internal_state() const {
  return static_cast< ::snakes::GameState_Snake_SnakeState >(state_);
}
inline ::snakes::GameState_Snake_SnakeState GameState_Snake::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.state)
  return _internal_state();
}
inline void GameState_Snake::_internal_set_state(::snakes::GameState_Snake_SnakeState value) {
  assert(::snakes::GameState_Snake_SnakeState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void GameState_Snake::set_state(::snakes::GameState_Snake_SnakeState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.state)
}

// required .snakes.Direction head_direction = 4;
inline bool GameState_Snake::_internal_has_head_direction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameState_Snake::has_head_direction() const {
  return _internal_has_head_direction();
}
inline void GameState_Snake::clear_head_direction() {
  head_direction_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::snakes::Direction GameState_Snake::_internal_head_direction() const {
  return static_cast< ::snakes::Direction >(head_direction_);
}
inline ::snakes::Direction GameState_Snake::head_direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.Snake.head_direction)
  return _internal_head_direction();
}
inline void GameState_Snake::_internal_set_head_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  head_direction_ = value;
}
inline void GameState_Snake::set_head_direction(::snakes::Direction value) {
  _internal_set_head_direction(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.Snake.head_direction)
}

// -------------------------------------------------------------------

// GameState

// required int32 state_order = 1;
inline bool GameState::_internal_has_state_order() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameState::has_state_order() const {
  return _internal_has_state_order();
}
inline void GameState::clear_state_order() {
  state_order_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState::_internal_state_order() const {
  return state_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameState::state_order() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.state_order)
  return _internal_state_order();
}
inline void GameState::_internal_set_state_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  state_order_ = value;
}
inline void GameState::set_state_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_state_order(value);
  // @@protoc_insertion_point(field_set:snakes.GameState.state_order)
}

// repeated .snakes.GameState.Snake snakes = 2;
inline int GameState::_internal_snakes_size() const {
  return snakes_.size();
}
inline int GameState::snakes_size() const {
  return _internal_snakes_size();
}
inline void GameState::clear_snakes() {
  snakes_.Clear();
}
inline ::snakes::GameState_Snake* GameState::mutable_snakes(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.snakes)
  return snakes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >*
GameState::mutable_snakes() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.snakes)
  return &snakes_;
}
inline const ::snakes::GameState_Snake& GameState::_internal_snakes(int index) const {
  return snakes_.Get(index);
}
inline const ::snakes::GameState_Snake& GameState::snakes(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.snakes)
  return _internal_snakes(index);
}
inline ::snakes::GameState_Snake* GameState::_internal_add_snakes() {
  return snakes_.Add();
}
inline ::snakes::GameState_Snake* GameState::add_snakes() {
  // @@protoc_insertion_point(field_add:snakes.GameState.snakes)
  return _internal_add_snakes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Snake >&
GameState::snakes() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.snakes)
  return snakes_;
}

// repeated .snakes.GameState.Coord foods = 3;
inline int GameState::_internal_foods_size() const {
  return foods_.size();
}
inline int GameState::foods_size() const {
  return _internal_foods_size();
}
inline void GameState::clear_foods() {
  foods_.Clear();
}
inline ::snakes::GameState_Coord* GameState::mutable_foods(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.foods)
  return foods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >*
GameState::mutable_foods() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameState.foods)
  return &foods_;
}
inline const ::snakes::GameState_Coord& GameState::_internal_foods(int index) const {
  return foods_.Get(index);
}
inline const ::snakes::GameState_Coord& GameState::foods(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameState.foods)
  return _internal_foods(index);
}
inline ::snakes::GameState_Coord* GameState::_internal_add_foods() {
  return foods_.Add();
}
inline ::snakes::GameState_Coord* GameState::add_foods() {
  // @@protoc_insertion_point(field_add:snakes.GameState.foods)
  return _internal_add_foods();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameState_Coord >&
GameState::foods() const {
  // @@protoc_insertion_point(field_list:snakes.GameState.foods)
  return foods_;
}

// required .snakes.GamePlayers players = 4;
inline bool GameState::_internal_has_players() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || players_ != nullptr);
  return value;
}
inline bool GameState::has_players() const {
  return _internal_has_players();
}
inline void GameState::clear_players() {
  if (players_ != nullptr) players_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::snakes::GamePlayers& GameState::_internal_players() const {
  const ::snakes::GamePlayers* p = players_;
  return p != nullptr ? *p : *reinterpret_cast<const ::snakes::GamePlayers*>(
      &::snakes::_GamePlayers_default_instance_);
}
inline const ::snakes::GamePlayers& GameState::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameState.players)
  return _internal_players();
}
inline void GameState::unsafe_arena_set_allocated_players(
    ::snakes::GamePlayers* players) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(players_);
  }
  players_ = players;
  if (players) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameState.players)
}
inline ::snakes::GamePlayers* GameState::release_players() {
  auto temp = unsafe_arena_release_players();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::snakes::GamePlayers* GameState::unsafe_arena_release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameState.players)
  _has_bits_[0] &= ~0x00000001u;
  ::snakes::GamePlayers* temp = players_;
  players_ = nullptr;
  return temp;
}
inline ::snakes::GamePlayers* GameState::_internal_mutable_players() {
  _has_bits_[0] |= 0x00000001u;
  if (players_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GamePlayers>(GetArena());
    players_ = p;
  }
  return players_;
}
inline ::snakes::GamePlayers* GameState::mutable_players() {
  // @@protoc_insertion_point(field_mutable:snakes.GameState.players)
  return _internal_mutable_players();
}
inline void GameState::set_allocated_players(::snakes::GamePlayers* players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete players_;
  }
  if (players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(players);
    if (message_arena != submessage_arena) {
      players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, players, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  players_ = players;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameState.players)
}

// -------------------------------------------------------------------

// GameAnnouncement

// required .snakes.GamePlayers players = 1;
inline bool GameAnnouncement::_internal_has_players() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || players_ != nullptr);
  return value;
}
inline bool GameAnnouncement::has_players() const {
  return _internal_has_players();
}
inline void GameAnnouncement::clear_players() {
  if (players_ != nullptr) players_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::snakes::GamePlayers& GameAnnouncement::_internal_players() const {
  const ::snakes::GamePlayers* p = players_;
  return p != nullptr ? *p : *reinterpret_cast<const ::snakes::GamePlayers*>(
      &::snakes::_GamePlayers_default_instance_);
}
inline const ::snakes::GamePlayers& GameAnnouncement::players() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.players)
  return _internal_players();
}
inline void GameAnnouncement::unsafe_arena_set_allocated_players(
    ::snakes::GamePlayers* players) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(players_);
  }
  players_ = players;
  if (players) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameAnnouncement.players)
}
inline ::snakes::GamePlayers* GameAnnouncement::release_players() {
  auto temp = unsafe_arena_release_players();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::snakes::GamePlayers* GameAnnouncement::unsafe_arena_release_players() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.players)
  _has_bits_[0] &= ~0x00000002u;
  ::snakes::GamePlayers* temp = players_;
  players_ = nullptr;
  return temp;
}
inline ::snakes::GamePlayers* GameAnnouncement::_internal_mutable_players() {
  _has_bits_[0] |= 0x00000002u;
  if (players_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GamePlayers>(GetArena());
    players_ = p;
  }
  return players_;
}
inline ::snakes::GamePlayers* GameAnnouncement::mutable_players() {
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.players)
  return _internal_mutable_players();
}
inline void GameAnnouncement::set_allocated_players(::snakes::GamePlayers* players) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete players_;
  }
  if (players) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(players);
    if (message_arena != submessage_arena) {
      players = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, players, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  players_ = players;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.players)
}

// required .snakes.GameConfig config = 2;
inline bool GameAnnouncement::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool GameAnnouncement::has_config() const {
  return _internal_has_config();
}
inline void GameAnnouncement::clear_config() {
  if (config_ != nullptr) config_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::snakes::GameConfig& GameAnnouncement::_internal_config() const {
  const ::snakes::GameConfig* p = config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::snakes::GameConfig*>(
      &::snakes::_GameConfig_default_instance_);
}
inline const ::snakes::GameConfig& GameAnnouncement::config() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.config)
  return _internal_config();
}
inline void GameAnnouncement::unsafe_arena_set_allocated_config(
    ::snakes::GameConfig* config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameAnnouncement.config)
}
inline ::snakes::GameConfig* GameAnnouncement::release_config() {
  auto temp = unsafe_arena_release_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::snakes::GameConfig* GameAnnouncement::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.config)
  _has_bits_[0] &= ~0x00000004u;
  ::snakes::GameConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::snakes::GameConfig* GameAnnouncement::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000004u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GameConfig>(GetArena());
    config_ = p;
  }
  return config_;
}
inline ::snakes::GameConfig* GameAnnouncement::mutable_config() {
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.config)
  return _internal_mutable_config();
}
inline void GameAnnouncement::set_allocated_config(::snakes::GameConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.config)
}

// optional bool can_join = 3 [default = true];
inline bool GameAnnouncement::_internal_has_can_join() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameAnnouncement::has_can_join() const {
  return _internal_has_can_join();
}
inline void GameAnnouncement::clear_can_join() {
  can_join_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GameAnnouncement::_internal_can_join() const {
  return can_join_;
}
inline bool GameAnnouncement::can_join() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.can_join)
  return _internal_can_join();
}
inline void GameAnnouncement::_internal_set_can_join(bool value) {
  _has_bits_[0] |= 0x00000008u;
  can_join_ = value;
}
inline void GameAnnouncement::set_can_join(bool value) {
  _internal_set_can_join(value);
  // @@protoc_insertion_point(field_set:snakes.GameAnnouncement.can_join)
}

// required string game_name = 4;
inline bool GameAnnouncement::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameAnnouncement::has_game_name() const {
  return _internal_has_game_name();
}
inline void GameAnnouncement::clear_game_name() {
  game_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameAnnouncement::game_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameAnnouncement.game_name)
  return _internal_game_name();
}
inline void GameAnnouncement::set_game_name(const std::string& value) {
  _internal_set_game_name(value);
  // @@protoc_insertion_point(field_set:snakes.GameAnnouncement.game_name)
}
inline std::string* GameAnnouncement::mutable_game_name() {
  // @@protoc_insertion_point(field_mutable:snakes.GameAnnouncement.game_name)
  return _internal_mutable_game_name();
}
inline const std::string& GameAnnouncement::_internal_game_name() const {
  return game_name_.Get();
}
inline void GameAnnouncement::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameAnnouncement::set_game_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GameAnnouncement.game_name)
}
inline void GameAnnouncement::set_game_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GameAnnouncement.game_name)
}
inline void GameAnnouncement::set_game_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GameAnnouncement.game_name)
}
inline std::string* GameAnnouncement::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  return game_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameAnnouncement::release_game_name() {
  // @@protoc_insertion_point(field_release:snakes.GameAnnouncement.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameAnnouncement::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GameAnnouncement.game_name)
}
inline std::string* GameAnnouncement::unsafe_arena_release_game_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameAnnouncement.game_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return game_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GameAnnouncement::unsafe_arena_set_allocated_game_name(
    std::string* game_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      game_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameAnnouncement.game_name)
}

// -------------------------------------------------------------------

// GameMessage_PingMsg

// -------------------------------------------------------------------

// GameMessage_SteerMsg

// required .snakes.Direction direction = 1;
inline bool GameMessage_SteerMsg::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_SteerMsg::has_direction() const {
  return _internal_has_direction();
}
inline void GameMessage_SteerMsg::clear_direction() {
  direction_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::snakes::Direction GameMessage_SteerMsg::_internal_direction() const {
  return static_cast< ::snakes::Direction >(direction_);
}
inline ::snakes::Direction GameMessage_SteerMsg::direction() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.SteerMsg.direction)
  return _internal_direction();
}
inline void GameMessage_SteerMsg::_internal_set_direction(::snakes::Direction value) {
  assert(::snakes::Direction_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  direction_ = value;
}
inline void GameMessage_SteerMsg::set_direction(::snakes::Direction value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.SteerMsg.direction)
}

// -------------------------------------------------------------------

// GameMessage_AckMsg

// -------------------------------------------------------------------

// GameMessage_StateMsg

// required .snakes.GameState state = 1;
inline bool GameMessage_StateMsg::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || state_ != nullptr);
  return value;
}
inline bool GameMessage_StateMsg::has_state() const {
  return _internal_has_state();
}
inline void GameMessage_StateMsg::clear_state() {
  if (state_ != nullptr) state_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::snakes::GameState& GameMessage_StateMsg::_internal_state() const {
  const ::snakes::GameState* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::snakes::GameState*>(
      &::snakes::_GameState_default_instance_);
}
inline const ::snakes::GameState& GameMessage_StateMsg::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.StateMsg.state)
  return _internal_state();
}
inline void GameMessage_StateMsg::unsafe_arena_set_allocated_state(
    ::snakes::GameState* state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.StateMsg.state)
}
inline ::snakes::GameState* GameMessage_StateMsg::release_state() {
  auto temp = unsafe_arena_release_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::snakes::GameState* GameMessage_StateMsg::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.StateMsg.state)
  _has_bits_[0] &= ~0x00000001u;
  ::snakes::GameState* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::snakes::GameState* GameMessage_StateMsg::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000001u;
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::snakes::GameState>(GetArena());
    state_ = p;
  }
  return state_;
}
inline ::snakes::GameState* GameMessage_StateMsg::mutable_state() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.StateMsg.state)
  return _internal_mutable_state();
}
inline void GameMessage_StateMsg::set_allocated_state(::snakes::GameState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.StateMsg.state)
}

// -------------------------------------------------------------------

// GameMessage_AnnouncementMsg

// repeated .snakes.GameAnnouncement games = 1;
inline int GameMessage_AnnouncementMsg::_internal_games_size() const {
  return games_.size();
}
inline int GameMessage_AnnouncementMsg::games_size() const {
  return _internal_games_size();
}
inline void GameMessage_AnnouncementMsg::clear_games() {
  games_.Clear();
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::mutable_games(int index) {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.AnnouncementMsg.games)
  return games_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >*
GameMessage_AnnouncementMsg::mutable_games() {
  // @@protoc_insertion_point(field_mutable_list:snakes.GameMessage.AnnouncementMsg.games)
  return &games_;
}
inline const ::snakes::GameAnnouncement& GameMessage_AnnouncementMsg::_internal_games(int index) const {
  return games_.Get(index);
}
inline const ::snakes::GameAnnouncement& GameMessage_AnnouncementMsg::games(int index) const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.AnnouncementMsg.games)
  return _internal_games(index);
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::_internal_add_games() {
  return games_.Add();
}
inline ::snakes::GameAnnouncement* GameMessage_AnnouncementMsg::add_games() {
  // @@protoc_insertion_point(field_add:snakes.GameMessage.AnnouncementMsg.games)
  return _internal_add_games();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::snakes::GameAnnouncement >&
GameMessage_AnnouncementMsg::games() const {
  // @@protoc_insertion_point(field_list:snakes.GameMessage.AnnouncementMsg.games)
  return games_;
}

// -------------------------------------------------------------------

// GameMessage_DiscoverMsg

// -------------------------------------------------------------------

// GameMessage_JoinMsg

// optional .snakes.PlayerType player_type = 1 [default = HUMAN];
inline bool GameMessage_JoinMsg::_internal_has_player_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_player_type() const {
  return _internal_has_player_type();
}
inline void GameMessage_JoinMsg::clear_player_type() {
  player_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::snakes::PlayerType GameMessage_JoinMsg::_internal_player_type() const {
  return static_cast< ::snakes::PlayerType >(player_type_);
}
inline ::snakes::PlayerType GameMessage_JoinMsg::player_type() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.player_type)
  return _internal_player_type();
}
inline void GameMessage_JoinMsg::_internal_set_player_type(::snakes::PlayerType value) {
  assert(::snakes::PlayerType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  player_type_ = value;
}
inline void GameMessage_JoinMsg::set_player_type(::snakes::PlayerType value) {
  _internal_set_player_type(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.player_type)
}

// required string player_name = 3;
inline bool GameMessage_JoinMsg::_internal_has_player_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_player_name() const {
  return _internal_has_player_name();
}
inline void GameMessage_JoinMsg::clear_player_name() {
  player_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameMessage_JoinMsg::player_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.player_name)
  return _internal_player_name();
}
inline void GameMessage_JoinMsg::set_player_name(const std::string& value) {
  _internal_set_player_name(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.player_name)
}
inline std::string* GameMessage_JoinMsg::mutable_player_name() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.JoinMsg.player_name)
  return _internal_mutable_player_name();
}
inline const std::string& GameMessage_JoinMsg::_internal_player_name() const {
  return player_name_.Get();
}
inline void GameMessage_JoinMsg::_internal_set_player_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameMessage_JoinMsg::set_player_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GameMessage.JoinMsg.player_name)
}
inline void GameMessage_JoinMsg::set_player_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GameMessage.JoinMsg.player_name)
}
inline void GameMessage_JoinMsg::set_player_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  player_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GameMessage.JoinMsg.player_name)
}
inline std::string* GameMessage_JoinMsg::_internal_mutable_player_name() {
  _has_bits_[0] |= 0x00000001u;
  return player_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameMessage_JoinMsg::release_player_name() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.JoinMsg.player_name)
  if (!_internal_has_player_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameMessage_JoinMsg::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), player_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.JoinMsg.player_name)
}
inline std::string* GameMessage_JoinMsg::unsafe_arena_release_player_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.JoinMsg.player_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return player_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GameMessage_JoinMsg::unsafe_arena_set_allocated_player_name(
    std::string* player_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (player_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  player_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      player_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.JoinMsg.player_name)
}

// required string game_name = 4;
inline bool GameMessage_JoinMsg::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_game_name() const {
  return _internal_has_game_name();
}
inline void GameMessage_JoinMsg::clear_game_name() {
  game_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameMessage_JoinMsg::game_name() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.game_name)
  return _internal_game_name();
}
inline void GameMessage_JoinMsg::set_game_name(const std::string& value) {
  _internal_set_game_name(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.game_name)
}
inline std::string* GameMessage_JoinMsg::mutable_game_name() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.JoinMsg.game_name)
  return _internal_mutable_game_name();
}
inline const std::string& GameMessage_JoinMsg::_internal_game_name() const {
  return game_name_.Get();
}
inline void GameMessage_JoinMsg::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameMessage_JoinMsg::set_game_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  game_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GameMessage.JoinMsg.game_name)
}
inline void GameMessage_JoinMsg::set_game_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GameMessage.JoinMsg.game_name)
}
inline void GameMessage_JoinMsg::set_game_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GameMessage.JoinMsg.game_name)
}
inline std::string* GameMessage_JoinMsg::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000002u;
  return game_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameMessage_JoinMsg::release_game_name() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.JoinMsg.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameMessage_JoinMsg::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.JoinMsg.game_name)
}
inline std::string* GameMessage_JoinMsg::unsafe_arena_release_game_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.JoinMsg.game_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return game_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GameMessage_JoinMsg::unsafe_arena_set_allocated_game_name(
    std::string* game_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      game_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.JoinMsg.game_name)
}

// required .snakes.NodeRole requested_role = 5;
inline bool GameMessage_JoinMsg::_internal_has_requested_role() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameMessage_JoinMsg::has_requested_role() const {
  return _internal_has_requested_role();
}
inline void GameMessage_JoinMsg::clear_requested_role() {
  requested_role_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::snakes::NodeRole GameMessage_JoinMsg::_internal_requested_role() const {
  return static_cast< ::snakes::NodeRole >(requested_role_);
}
inline ::snakes::NodeRole GameMessage_JoinMsg::requested_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.JoinMsg.requested_role)
  return _internal_requested_role();
}
inline void GameMessage_JoinMsg::_internal_set_requested_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  requested_role_ = value;
}
inline void GameMessage_JoinMsg::set_requested_role(::snakes::NodeRole value) {
  _internal_set_requested_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.JoinMsg.requested_role)
}

// -------------------------------------------------------------------

// GameMessage_ErrorMsg

// required string error_message = 1;
inline bool GameMessage_ErrorMsg::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_ErrorMsg::has_error_message() const {
  return _internal_has_error_message();
}
inline void GameMessage_ErrorMsg::clear_error_message() {
  error_message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameMessage_ErrorMsg::error_message() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ErrorMsg.error_message)
  return _internal_error_message();
}
inline void GameMessage_ErrorMsg::set_error_message(const std::string& value) {
  _internal_set_error_message(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.ErrorMsg.error_message)
}
inline std::string* GameMessage_ErrorMsg::mutable_error_message() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ErrorMsg.error_message)
  return _internal_mutable_error_message();
}
inline const std::string& GameMessage_ErrorMsg::_internal_error_message() const {
  return error_message_.Get();
}
inline void GameMessage_ErrorMsg::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameMessage_ErrorMsg::set_error_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:snakes.GameMessage.ErrorMsg.error_message)
}
inline void GameMessage_ErrorMsg::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:snakes.GameMessage.ErrorMsg.error_message)
}
inline void GameMessage_ErrorMsg::set_error_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:snakes.GameMessage.ErrorMsg.error_message)
}
inline std::string* GameMessage_ErrorMsg::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameMessage_ErrorMsg::release_error_message() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ErrorMsg.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameMessage_ErrorMsg::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:snakes.GameMessage.ErrorMsg.error_message)
}
inline std::string* GameMessage_ErrorMsg::unsafe_arena_release_error_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.ErrorMsg.error_message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GameMessage_ErrorMsg::unsafe_arena_set_allocated_error_message(
    std::string* error_message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error_message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.ErrorMsg.error_message)
}

// -------------------------------------------------------------------

// GameMessage_RoleChangeMsg

// optional .snakes.NodeRole sender_role = 1;
inline bool GameMessage_RoleChangeMsg::_internal_has_sender_role() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage_RoleChangeMsg::has_sender_role() const {
  return _internal_has_sender_role();
}
inline void GameMessage_RoleChangeMsg::clear_sender_role() {
  sender_role_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::_internal_sender_role() const {
  return static_cast< ::snakes::NodeRole >(sender_role_);
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::sender_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.sender_role)
  return _internal_sender_role();
}
inline void GameMessage_RoleChangeMsg::_internal_set_sender_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  sender_role_ = value;
}
inline void GameMessage_RoleChangeMsg::set_sender_role(::snakes::NodeRole value) {
  _internal_set_sender_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.sender_role)
}

// optional .snakes.NodeRole receiver_role = 2;
inline bool GameMessage_RoleChangeMsg::_internal_has_receiver_role() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage_RoleChangeMsg::has_receiver_role() const {
  return _internal_has_receiver_role();
}
inline void GameMessage_RoleChangeMsg::clear_receiver_role() {
  receiver_role_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::_internal_receiver_role() const {
  return static_cast< ::snakes::NodeRole >(receiver_role_);
}
inline ::snakes::NodeRole GameMessage_RoleChangeMsg::receiver_role() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.RoleChangeMsg.receiver_role)
  return _internal_receiver_role();
}
inline void GameMessage_RoleChangeMsg::_internal_set_receiver_role(::snakes::NodeRole value) {
  assert(::snakes::NodeRole_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  receiver_role_ = value;
}
inline void GameMessage_RoleChangeMsg::set_receiver_role(::snakes::NodeRole value) {
  _internal_set_receiver_role(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.RoleChangeMsg.receiver_role)
}

// -------------------------------------------------------------------

// GameMessage

// required int64 msg_seq = 1;
inline bool GameMessage::_internal_has_msg_seq() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameMessage::has_msg_seq() const {
  return _internal_has_msg_seq();
}
inline void GameMessage::clear_msg_seq() {
  msg_seq_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameMessage::_internal_msg_seq() const {
  return msg_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameMessage::msg_seq() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.msg_seq)
  return _internal_msg_seq();
}
inline void GameMessage::_internal_set_msg_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  msg_seq_ = value;
}
inline void GameMessage::set_msg_seq(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_msg_seq(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.msg_seq)
}

// optional int32 sender_id = 10;
inline bool GameMessage::_internal_has_sender_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameMessage::has_sender_id() const {
  return _internal_has_sender_id();
}
inline void GameMessage::clear_sender_id() {
  sender_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameMessage::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameMessage::sender_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.sender_id)
  return _internal_sender_id();
}
inline void GameMessage::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  sender_id_ = value;
}
inline void GameMessage::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.sender_id)
}

// optional int32 receiver_id = 11;
inline bool GameMessage::_internal_has_receiver_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameMessage::has_receiver_id() const {
  return _internal_has_receiver_id();
}
inline void GameMessage::clear_receiver_id() {
  receiver_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameMessage::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameMessage::receiver_id() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.receiver_id)
  return _internal_receiver_id();
}
inline void GameMessage::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  receiver_id_ = value;
}
inline void GameMessage::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:snakes.GameMessage.receiver_id)
}

// .snakes.GameMessage.PingMsg ping = 2;
inline bool GameMessage::_internal_has_ping() const {
  return Type_case() == kPing;
}
inline bool GameMessage::has_ping() const {
  return _internal_has_ping();
}
inline void GameMessage::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void GameMessage::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArena() == nullptr) {
      delete Type_.ping_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_PingMsg* GameMessage::release_ping() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ping)
  if (_internal_has_ping()) {
    clear_has_Type();
      ::snakes::GameMessage_PingMsg* temp = Type_.ping_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_PingMsg& GameMessage::_internal_ping() const {
  return _internal_has_ping()
      ? *Type_.ping_
      : *reinterpret_cast< ::snakes::GameMessage_PingMsg*>(&::snakes::_GameMessage_PingMsg_default_instance_);
}
inline const ::snakes::GameMessage_PingMsg& GameMessage::ping() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ping)
  return _internal_ping();
}
inline ::snakes::GameMessage_PingMsg* GameMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.ping)
  if (_internal_has_ping()) {
    clear_has_Type();
    ::snakes::GameMessage_PingMsg* temp = Type_.ping_;
    Type_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_ping(::snakes::GameMessage_PingMsg* ping) {
  clear_Type();
  if (ping) {
    set_has_ping();
    Type_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.ping)
}
inline ::snakes::GameMessage_PingMsg* GameMessage::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_Type();
    set_has_ping();
    Type_.ping_ = CreateMaybeMessage< ::snakes::GameMessage_PingMsg >(GetArena());
  }
  return Type_.ping_;
}
inline ::snakes::GameMessage_PingMsg* GameMessage::mutable_ping() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ping)
  return _internal_mutable_ping();
}

// .snakes.GameMessage.SteerMsg steer = 3;
inline bool GameMessage::_internal_has_steer() const {
  return Type_case() == kSteer;
}
inline bool GameMessage::has_steer() const {
  return _internal_has_steer();
}
inline void GameMessage::set_has_steer() {
  _oneof_case_[0] = kSteer;
}
inline void GameMessage::clear_steer() {
  if (_internal_has_steer()) {
    if (GetArena() == nullptr) {
      delete Type_.steer_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::release_steer() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.steer)
  if (_internal_has_steer()) {
    clear_has_Type();
      ::snakes::GameMessage_SteerMsg* temp = Type_.steer_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.steer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_SteerMsg& GameMessage::_internal_steer() const {
  return _internal_has_steer()
      ? *Type_.steer_
      : *reinterpret_cast< ::snakes::GameMessage_SteerMsg*>(&::snakes::_GameMessage_SteerMsg_default_instance_);
}
inline const ::snakes::GameMessage_SteerMsg& GameMessage::steer() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.steer)
  return _internal_steer();
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::unsafe_arena_release_steer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.steer)
  if (_internal_has_steer()) {
    clear_has_Type();
    ::snakes::GameMessage_SteerMsg* temp = Type_.steer_;
    Type_.steer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_steer(::snakes::GameMessage_SteerMsg* steer) {
  clear_Type();
  if (steer) {
    set_has_steer();
    Type_.steer_ = steer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.steer)
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::_internal_mutable_steer() {
  if (!_internal_has_steer()) {
    clear_Type();
    set_has_steer();
    Type_.steer_ = CreateMaybeMessage< ::snakes::GameMessage_SteerMsg >(GetArena());
  }
  return Type_.steer_;
}
inline ::snakes::GameMessage_SteerMsg* GameMessage::mutable_steer() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.steer)
  return _internal_mutable_steer();
}

// .snakes.GameMessage.AckMsg ack = 4;
inline bool GameMessage::_internal_has_ack() const {
  return Type_case() == kAck;
}
inline bool GameMessage::has_ack() const {
  return _internal_has_ack();
}
inline void GameMessage::set_has_ack() {
  _oneof_case_[0] = kAck;
}
inline void GameMessage::clear_ack() {
  if (_internal_has_ack()) {
    if (GetArena() == nullptr) {
      delete Type_.ack_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_AckMsg* GameMessage::release_ack() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.ack)
  if (_internal_has_ack()) {
    clear_has_Type();
      ::snakes::GameMessage_AckMsg* temp = Type_.ack_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_AckMsg& GameMessage::_internal_ack() const {
  return _internal_has_ack()
      ? *Type_.ack_
      : *reinterpret_cast< ::snakes::GameMessage_AckMsg*>(&::snakes::_GameMessage_AckMsg_default_instance_);
}
inline const ::snakes::GameMessage_AckMsg& GameMessage::ack() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.ack)
  return _internal_ack();
}
inline ::snakes::GameMessage_AckMsg* GameMessage::unsafe_arena_release_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.ack)
  if (_internal_has_ack()) {
    clear_has_Type();
    ::snakes::GameMessage_AckMsg* temp = Type_.ack_;
    Type_.ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_ack(::snakes::GameMessage_AckMsg* ack) {
  clear_Type();
  if (ack) {
    set_has_ack();
    Type_.ack_ = ack;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.ack)
}
inline ::snakes::GameMessage_AckMsg* GameMessage::_internal_mutable_ack() {
  if (!_internal_has_ack()) {
    clear_Type();
    set_has_ack();
    Type_.ack_ = CreateMaybeMessage< ::snakes::GameMessage_AckMsg >(GetArena());
  }
  return Type_.ack_;
}
inline ::snakes::GameMessage_AckMsg* GameMessage::mutable_ack() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.ack)
  return _internal_mutable_ack();
}

// .snakes.GameMessage.StateMsg state = 5;
inline bool GameMessage::_internal_has_state() const {
  return Type_case() == kState;
}
inline bool GameMessage::has_state() const {
  return _internal_has_state();
}
inline void GameMessage::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void GameMessage::clear_state() {
  if (_internal_has_state()) {
    if (GetArena() == nullptr) {
      delete Type_.state_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_StateMsg* GameMessage::release_state() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.state)
  if (_internal_has_state()) {
    clear_has_Type();
      ::snakes::GameMessage_StateMsg* temp = Type_.state_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_StateMsg& GameMessage::_internal_state() const {
  return _internal_has_state()
      ? *Type_.state_
      : *reinterpret_cast< ::snakes::GameMessage_StateMsg*>(&::snakes::_GameMessage_StateMsg_default_instance_);
}
inline const ::snakes::GameMessage_StateMsg& GameMessage::state() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.state)
  return _internal_state();
}
inline ::snakes::GameMessage_StateMsg* GameMessage::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.state)
  if (_internal_has_state()) {
    clear_has_Type();
    ::snakes::GameMessage_StateMsg* temp = Type_.state_;
    Type_.state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_state(::snakes::GameMessage_StateMsg* state) {
  clear_Type();
  if (state) {
    set_has_state();
    Type_.state_ = state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.state)
}
inline ::snakes::GameMessage_StateMsg* GameMessage::_internal_mutable_state() {
  if (!_internal_has_state()) {
    clear_Type();
    set_has_state();
    Type_.state_ = CreateMaybeMessage< ::snakes::GameMessage_StateMsg >(GetArena());
  }
  return Type_.state_;
}
inline ::snakes::GameMessage_StateMsg* GameMessage::mutable_state() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.state)
  return _internal_mutable_state();
}

// .snakes.GameMessage.AnnouncementMsg announcement = 6;
inline bool GameMessage::_internal_has_announcement() const {
  return Type_case() == kAnnouncement;
}
inline bool GameMessage::has_announcement() const {
  return _internal_has_announcement();
}
inline void GameMessage::set_has_announcement() {
  _oneof_case_[0] = kAnnouncement;
}
inline void GameMessage::clear_announcement() {
  if (_internal_has_announcement()) {
    if (GetArena() == nullptr) {
      delete Type_.announcement_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::release_announcement() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.announcement)
  if (_internal_has_announcement()) {
    clear_has_Type();
      ::snakes::GameMessage_AnnouncementMsg* temp = Type_.announcement_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.announcement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_AnnouncementMsg& GameMessage::_internal_announcement() const {
  return _internal_has_announcement()
      ? *Type_.announcement_
      : *reinterpret_cast< ::snakes::GameMessage_AnnouncementMsg*>(&::snakes::_GameMessage_AnnouncementMsg_default_instance_);
}
inline const ::snakes::GameMessage_AnnouncementMsg& GameMessage::announcement() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.announcement)
  return _internal_announcement();
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::unsafe_arena_release_announcement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.announcement)
  if (_internal_has_announcement()) {
    clear_has_Type();
    ::snakes::GameMessage_AnnouncementMsg* temp = Type_.announcement_;
    Type_.announcement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_announcement(::snakes::GameMessage_AnnouncementMsg* announcement) {
  clear_Type();
  if (announcement) {
    set_has_announcement();
    Type_.announcement_ = announcement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.announcement)
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::_internal_mutable_announcement() {
  if (!_internal_has_announcement()) {
    clear_Type();
    set_has_announcement();
    Type_.announcement_ = CreateMaybeMessage< ::snakes::GameMessage_AnnouncementMsg >(GetArena());
  }
  return Type_.announcement_;
}
inline ::snakes::GameMessage_AnnouncementMsg* GameMessage::mutable_announcement() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.announcement)
  return _internal_mutable_announcement();
}

// .snakes.GameMessage.JoinMsg join = 7;
inline bool GameMessage::_internal_has_join() const {
  return Type_case() == kJoin;
}
inline bool GameMessage::has_join() const {
  return _internal_has_join();
}
inline void GameMessage::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void GameMessage::clear_join() {
  if (_internal_has_join()) {
    if (GetArena() == nullptr) {
      delete Type_.join_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::release_join() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.join)
  if (_internal_has_join()) {
    clear_has_Type();
      ::snakes::GameMessage_JoinMsg* temp = Type_.join_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_JoinMsg& GameMessage::_internal_join() const {
  return _internal_has_join()
      ? *Type_.join_
      : *reinterpret_cast< ::snakes::GameMessage_JoinMsg*>(&::snakes::_GameMessage_JoinMsg_default_instance_);
}
inline const ::snakes::GameMessage_JoinMsg& GameMessage::join() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.join)
  return _internal_join();
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::unsafe_arena_release_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.join)
  if (_internal_has_join()) {
    clear_has_Type();
    ::snakes::GameMessage_JoinMsg* temp = Type_.join_;
    Type_.join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_join(::snakes::GameMessage_JoinMsg* join) {
  clear_Type();
  if (join) {
    set_has_join();
    Type_.join_ = join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.join)
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::_internal_mutable_join() {
  if (!_internal_has_join()) {
    clear_Type();
    set_has_join();
    Type_.join_ = CreateMaybeMessage< ::snakes::GameMessage_JoinMsg >(GetArena());
  }
  return Type_.join_;
}
inline ::snakes::GameMessage_JoinMsg* GameMessage::mutable_join() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.join)
  return _internal_mutable_join();
}

// .snakes.GameMessage.ErrorMsg error = 8;
inline bool GameMessage::_internal_has_error() const {
  return Type_case() == kError;
}
inline bool GameMessage::has_error() const {
  return _internal_has_error();
}
inline void GameMessage::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void GameMessage::clear_error() {
  if (_internal_has_error()) {
    if (GetArena() == nullptr) {
      delete Type_.error_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::release_error() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.error)
  if (_internal_has_error()) {
    clear_has_Type();
      ::snakes::GameMessage_ErrorMsg* temp = Type_.error_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_ErrorMsg& GameMessage::_internal_error() const {
  return _internal_has_error()
      ? *Type_.error_
      : *reinterpret_cast< ::snakes::GameMessage_ErrorMsg*>(&::snakes::_GameMessage_ErrorMsg_default_instance_);
}
inline const ::snakes::GameMessage_ErrorMsg& GameMessage::error() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.error)
  return _internal_error();
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.error)
  if (_internal_has_error()) {
    clear_has_Type();
    ::snakes::GameMessage_ErrorMsg* temp = Type_.error_;
    Type_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_error(::snakes::GameMessage_ErrorMsg* error) {
  clear_Type();
  if (error) {
    set_has_error();
    Type_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.error)
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_Type();
    set_has_error();
    Type_.error_ = CreateMaybeMessage< ::snakes::GameMessage_ErrorMsg >(GetArena());
  }
  return Type_.error_;
}
inline ::snakes::GameMessage_ErrorMsg* GameMessage::mutable_error() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.error)
  return _internal_mutable_error();
}

// .snakes.GameMessage.RoleChangeMsg role_change = 9;
inline bool GameMessage::_internal_has_role_change() const {
  return Type_case() == kRoleChange;
}
inline bool GameMessage::has_role_change() const {
  return _internal_has_role_change();
}
inline void GameMessage::set_has_role_change() {
  _oneof_case_[0] = kRoleChange;
}
inline void GameMessage::clear_role_change() {
  if (_internal_has_role_change()) {
    if (GetArena() == nullptr) {
      delete Type_.role_change_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::release_role_change() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.role_change)
  if (_internal_has_role_change()) {
    clear_has_Type();
      ::snakes::GameMessage_RoleChangeMsg* temp = Type_.role_change_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.role_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_RoleChangeMsg& GameMessage::_internal_role_change() const {
  return _internal_has_role_change()
      ? *Type_.role_change_
      : *reinterpret_cast< ::snakes::GameMessage_RoleChangeMsg*>(&::snakes::_GameMessage_RoleChangeMsg_default_instance_);
}
inline const ::snakes::GameMessage_RoleChangeMsg& GameMessage::role_change() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.role_change)
  return _internal_role_change();
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::unsafe_arena_release_role_change() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.role_change)
  if (_internal_has_role_change()) {
    clear_has_Type();
    ::snakes::GameMessage_RoleChangeMsg* temp = Type_.role_change_;
    Type_.role_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_role_change(::snakes::GameMessage_RoleChangeMsg* role_change) {
  clear_Type();
  if (role_change) {
    set_has_role_change();
    Type_.role_change_ = role_change;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.role_change)
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::_internal_mutable_role_change() {
  if (!_internal_has_role_change()) {
    clear_Type();
    set_has_role_change();
    Type_.role_change_ = CreateMaybeMessage< ::snakes::GameMessage_RoleChangeMsg >(GetArena());
  }
  return Type_.role_change_;
}
inline ::snakes::GameMessage_RoleChangeMsg* GameMessage::mutable_role_change() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.role_change)
  return _internal_mutable_role_change();
}

// .snakes.GameMessage.DiscoverMsg discover = 12;
inline bool GameMessage::_internal_has_discover() const {
  return Type_case() == kDiscover;
}
inline bool GameMessage::has_discover() const {
  return _internal_has_discover();
}
inline void GameMessage::set_has_discover() {
  _oneof_case_[0] = kDiscover;
}
inline void GameMessage::clear_discover() {
  if (_internal_has_discover()) {
    if (GetArena() == nullptr) {
      delete Type_.discover_;
    }
    clear_has_Type();
  }
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::release_discover() {
  // @@protoc_insertion_point(field_release:snakes.GameMessage.discover)
  if (_internal_has_discover()) {
    clear_has_Type();
      ::snakes::GameMessage_DiscoverMsg* temp = Type_.discover_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Type_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::snakes::GameMessage_DiscoverMsg& GameMessage::_internal_discover() const {
  return _internal_has_discover()
      ? *Type_.discover_
      : *reinterpret_cast< ::snakes::GameMessage_DiscoverMsg*>(&::snakes::_GameMessage_DiscoverMsg_default_instance_);
}
inline const ::snakes::GameMessage_DiscoverMsg& GameMessage::discover() const {
  // @@protoc_insertion_point(field_get:snakes.GameMessage.discover)
  return _internal_discover();
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::unsafe_arena_release_discover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:snakes.GameMessage.discover)
  if (_internal_has_discover()) {
    clear_has_Type();
    ::snakes::GameMessage_DiscoverMsg* temp = Type_.discover_;
    Type_.discover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_discover(::snakes::GameMessage_DiscoverMsg* discover) {
  clear_Type();
  if (discover) {
    set_has_discover();
    Type_.discover_ = discover;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:snakes.GameMessage.discover)
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::_internal_mutable_discover() {
  if (!_internal_has_discover()) {
    clear_Type();
    set_has_discover();
    Type_.discover_ = CreateMaybeMessage< ::snakes::GameMessage_DiscoverMsg >(GetArena());
  }
  return Type_.discover_;
}
inline ::snakes::GameMessage_DiscoverMsg* GameMessage::mutable_discover() {
  // @@protoc_insertion_point(field_mutable:snakes.GameMessage.discover)
  return _internal_mutable_discover();
}

inline bool GameMessage::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void GameMessage::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline GameMessage::TypeCase GameMessage::Type_case() const {
  return GameMessage::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace snakes

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::snakes::GameState_Snake_SnakeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::GameState_Snake_SnakeState>() {
  return ::snakes::GameState_Snake_SnakeState_descriptor();
}
template <> struct is_proto_enum< ::snakes::NodeRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::NodeRole>() {
  return ::snakes::NodeRole_descriptor();
}
template <> struct is_proto_enum< ::snakes::PlayerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::PlayerType>() {
  return ::snakes::PlayerType_descriptor();
}
template <> struct is_proto_enum< ::snakes::Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::snakes::Direction>() {
  return ::snakes::Direction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_snakes_2eproto
